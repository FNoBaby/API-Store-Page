# Node.js E-Commerce API Implementation Guide with MySQL

This document provides detailed instructions for implementing an API using Node.js, Express, and MySQL that replicates the functionality of the PHP e-commerce application.

## 1. Project Setup

```bash
# Initialize a new Node.js project
npm init -y

# Install core dependencies
npm install express mysql2 bcryptjs jsonwebtoken dotenv cors multer express-validator helmet morgan cookie-parser

# Install development dependencies
npm install nodemon --save-dev
```

After initializing the project, add the following to package.json scripts:

```json
"scripts": {
  "start": "node server.js",
  "dev": "nodemon server.js",
  "test": "echo \"Error: no test specified\" && exit 1"
}
```

## 2. Project Structure

```
/e-commerce-api
  /config
    - db.js            # Database connection
    - env.js           # Environment variables
  /controllers
    - authController.js     # User authentication (login, register, etc.)
    - userController.js     # User CRUD operations
    - productController.js  # Product CRUD operations
    - categoryController.js # Category CRUD operations
    - cartController.js     # Cart operations
    - orderController.js    # Order processing
  /middleware
    - auth.js          # Authentication middleware
    - admin.js         # Admin authorization middleware
    - upload.js        # File upload middleware
    - validate.js      # Input validation middleware
    - errorHandler.js  # Global error handler  /models
    - User.js          # User model
    - Product.js       # Product model
    - Category.js      # Category model
    - Order.js         # Order model
    - Cart.js          # Cart model
  /routes
    - auth.js          # Authentication routes
    - users.js         # User routes
    - products.js      # Product routes
    - categories.js    # Category routes
    - cart.js          # Cart routes
    - orders.js        # Order routes
  /uploads             # Directory for uploaded files
  /utils
    - helpers.js       # Helper functions
  - .env               # Environment variables
  - .gitignore         # Git ignore file
  - app.js             # Express app setup
  - server.js          # Entry point
```

## 3. Database Setup

### MySQL Connection (config/db.js)

```javascript
const mysql = require('mysql2/promise');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create a connection pool to the MySQL database
const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USERNAME || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 's5_storedatabase',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// Test the database connection
async function testConnection() {
  try {
    const connection = await pool.getConnection();
    console.log('Database connection established successfully');
    connection.release();
    return true;
  } catch (error) {
    console.error('Database connection failed:', error);
    return false;
  }
}

module.exports = {
  pool,
  testConnection
};
```

### Example .env File (.env)

```
# Database Configuration
DB_HOST=localhost
DB_USERNAME=root
DB_PASSWORD=your_password
DB_NAME=s5_storedatabase

# JWT Configuration
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=1d

# Server Configuration
PORT=5000
NODE_ENV=development
```

module.exports = User;

## 4. Authentication and Authorization

### JWT Authentication (middleware/auth.js)

```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/User');

module.exports = async (req, res, next) => {
  try {
    // Get token from header
    const token = req.header('x-auth-token');
    
    if (!token) {
      return res.status(401).json({ message: 'No token, authorization denied' });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Add user from payload
    const user = await User.findById(decoded.userId).select('-password');
    if (!user) {
      return res.status(401).json({ message: 'Token is not valid' });
    }
    
    req.user = user;
    next();
  } catch (err) {
    res.status(401).json({ message: 'Token is not valid' });
  }
};
```

### Admin Authorization (middleware/admin.js)

```javascript
module.exports = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Access denied. Admin privileges required.' });
  }
};
```

## 5. API Routes and Controllers

### Authentication Routes (routes/auth.js)

```javascript
const express = require('express');
const router = express.Router();
const { register, login, getCurrentUser } = require('../controllers/authController');
const auth = require('../middleware/auth');

// Register a new user
router.post('/register', register);

// Login user
router.post('/login', login);

// Get current user
router.get('/me', auth, getCurrentUser);

module.exports = router;
```

### Authentication Controller (controllers/authController.js)

```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { validationResult } = require('express-validator');

// Register a new user
exports.register = async (req, res) => {
  try {
    const { name, surname, email, phone, password, role = 'customer' } = req.body;
    
    // Check if user already exists
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ message: 'User with this email already exists' });
    }
    
    user = await User.findOne({ phone });
    if (user) {
      return res.status(400).json({ message: 'User with this phone number already exists' });
    }
    
    // Create new user
    user = new User({
      name,
      surname,
      email,
      phone,
      password,
      role
    });
    
    await user.save();
    
    // Generate JWT
    const token = jwt.sign(
      { userId: user.id },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    res.status(201).json({
      token,
      user: {
        id: user.id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        role: user.role,
        profileImage: user.profileImage
      }
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

// Login user
exports.login = async (req, res) => {
  try {
    const { loginId, password } = req.body;
    
    // Check if user exists by email or phone
    const user = await User.findOne({
      $or: [{ email: loginId }, { phone: loginId }]
    });
    
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }
    
    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }
    
    // Generate JWT
    const token = jwt.sign(
      { userId: user.id },
      process.env.JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    res.json({
      token,
      user: {
        id: user.id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        role: user.role,
        profileImage: user.profileImage
      }
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get current user
exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    res.json(user);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};
```

### Product Routes Implementation

```javascript
const express = require('express');
const router = express.Router();
const { getAllProducts, getProductById, createProduct, updateProduct, deleteProduct, getRandomProducts } = require('../controllers/productController');
const auth = require('../middleware/auth');
const admin = require('../middleware/admin');
const upload = require('../middleware/upload');

// Public routes
router.get('/', getAllProducts);
router.get('/random', getRandomProducts);
router.get('/:id', getProductById);

// Protected admin routes
router.post('/', [auth, admin, upload.single('image')], createProduct);
router.put('/:id', [auth, admin, upload.single('image')], updateProduct);
router.delete('/:id', [auth, admin], deleteProduct);

module.exports = router;
```

## 6. Core Application Files

### Main Application Entry (server.js)

```javascript
const app = require('./app');
const { testConnection } = require('./config/db');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Set port
const PORT = process.env.PORT || 5000;

// Test database connection before starting server
(async () => {
  const dbConnected = await testConnection();
  
  if (dbConnected) {
    app.listen(PORT, () => {
      console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
    });
  } else {
    console.error('Failed to connect to database. Server will not start.');
    process.exit(1);
  }
})();
```

### Express Application Setup (app.js)

```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const path = require('path');
const errorHandler = require('./middleware/errorHandler');

// Import routes
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const productRoutes = require('./routes/products');
const categoryRoutes = require('./routes/categories');
const cartRoutes = require('./routes/cart');
const orderRoutes = require('./routes/orders');

// Initialize Express app
const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));

// Static folder for uploads
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/products', productRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/cart', cartRoutes);
app.use('/api/orders', orderRoutes);

// Health check route
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

// Error handling middleware
app.use(errorHandler);

// 404 handler
app.use((req, res) => {
  res.status(404).json({ message: 'Resource not found' });
});

module.exports = app;
```

## 7. File Upload Implementation

```javascript
const multer = require('multer');
const path = require('path');

// Set storage engine
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

// Check file type
function checkFileType(file, cb) {
  // Allowed file extensions
  const filetypes = /jpeg|jpg|png|gif/;
  // Check extension
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
  // Check mime type
  const mimetype = filetypes.test(file.mimetype);

  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Only image files are allowed'));
  }
}

// Initialize upload
const upload = multer({
  storage,
  limits: { fileSize: 5000000 }, // 5MB
  fileFilter: (req, file, cb) => {
    checkFileType(file, cb);
  }
});

module.exports = upload;
```

## 8. Cart Implementation

Since the original PHP application uses sessions for cart management, we'll need to create a database-backed cart system for our API. First, we need to create additional tables in the MySQL database:

```sql
-- Create carts table
CREATE TABLE IF NOT EXISTS carts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create cart_items table
CREATE TABLE IF NOT EXISTS cart_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    cart_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (cart_id) REFERENCES carts(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);
```

### Cart Model Implementation (models/Cart.js)

```javascript
const { pool } = require('../config/db');

class Cart {
  // Initialize a cart for a user (create if doesn't exist)
  static async initialize(userId) {
    try {
      // Check if cart exists
      const [carts] = await pool.execute(
        'SELECT id FROM carts WHERE user_id = ? LIMIT 1',
        [userId]
      );
      
      if (carts.length === 0) {
        // Create a new cart
        const [result] = await pool.execute(
          'INSERT INTO carts (user_id) VALUES (?)',
          [userId]
        );
        return result.insertId;
      }
      
      return carts[0].id;
    } catch (error) {
      console.error('Error initializing cart:', error);
      throw error;
    }
  }

  // Add a product to the cart
  static async addItem(userId, productId, quantity = 1) {
    try {
      // Get the cart ID (or create a new cart)
      const cartId = await this.initialize(userId);
      
      // Get product details
      const [products] = await pool.execute(
        'SELECT id, name, price, image FROM products WHERE id = ? AND active = 1 LIMIT 1',
        [productId]
      );
      
      if (products.length === 0) {
        throw new Error('Product not found or inactive');
      }
      
      // Check if item already exists in cart
      const [cartItems] = await pool.execute(
        'SELECT id, quantity FROM cart_items WHERE cart_id = ? AND product_id = ? LIMIT 1',
        [cartId, productId]
      );
      
      if (cartItems.length > 0) {
        // Update quantity
        await pool.execute(
          'UPDATE cart_items SET quantity = quantity + ? WHERE id = ?',
          [quantity, cartItems[0].id]
        );
      } else {
        // Add new item
        await pool.execute(
          'INSERT INTO cart_items (cart_id, product_id, quantity) VALUES (?, ?, ?)',
          [cartId, productId, quantity]
        );
      }
      
      return true;
    } catch (error) {
      console.error('Error adding item to cart:', error);
      throw error;
    }
  }

  // Update cart item quantity
  static async updateItem(userId, productId, quantity) {
    try {
      // Get cart ID
      const cartId = await this.initialize(userId);
      
      if (quantity <= 0) {
        // Remove item if quantity is zero or negative
        return await this.removeItem(userId, productId);
      }
      
      // Update item quantity
      const [result] = await pool.execute(
        'UPDATE cart_items SET quantity = ? WHERE cart_id = ? AND product_id = ?',
        [quantity, cartId, productId]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating cart item:', error);
      throw error;
    }
  }

  // Remove an item from the cart
  static async removeItem(userId, productId) {
    try {
      // Get cart ID
      const cartId = await this.initialize(userId);
      
      // Remove item
      const [result] = await pool.execute(
        'DELETE FROM cart_items WHERE cart_id = ? AND product_id = ?',
        [cartId, productId]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error removing item from cart:', error);
      throw error;
    }
  }

  // Get all items in the cart with product details
  static async getItems(userId) {
    try {
      const cartId = await this.initialize(userId);
      
      const [rows] = await pool.execute(
        `SELECT ci.id, ci.product_id, ci.quantity, 
                p.name, p.price, p.image,
                (p.price * ci.quantity) as subtotal
         FROM cart_items ci
         JOIN products p ON ci.product_id = p.id
         WHERE ci.cart_id = ?`,
        [cartId]
      );
      
      return rows;
    } catch (error) {
      console.error('Error getting cart items:', error);
      throw error;
    }
  }
  
  // Clear the entire cart
  static async clearCart(userId) {
    try {
      const cartId = await this.initialize(userId);
      
      await pool.execute(
        'DELETE FROM cart_items WHERE cart_id = ?',
        [cartId]
      );
      
      return true;
    } catch (error) {
      console.error('Error clearing cart:', error);
      throw error;
    }
  }
  
  // Get cart total
  static async getTotal(userId) {
    try {
      const cartId = await this.initialize(userId);
      
      const [rows] = await pool.execute(
        `SELECT SUM(p.price * ci.quantity) as total
         FROM cart_items ci
         JOIN products p ON ci.product_id = p.id
         WHERE ci.cart_id = ?`,
        [cartId]
      );
      
      return rows[0].total || 0;
    } catch (error) {
      console.error('Error calculating cart total:', error);
      throw error;
    }
  }
  
  // Get number of items in cart
  static async getItemCount(userId) {
    try {
      const cartId = await this.initialize(userId);
      
      const [rows] = await pool.execute(
        `SELECT COUNT(*) as count
         FROM cart_items
         WHERE cart_id = ?`,
        [cartId]
      );
      
      return rows[0].count || 0;
    } catch (error) {
      console.error('Error getting cart item count:', error);
      throw error;
    }
  }
}

module.exports = Cart;
```

## 9. Order Implementation

### Order Model Implementation (models/Order.js)

```javascript
const { pool } = require('../config/db');
const Cart = require('./Cart');

class Order {
  constructor(orderData) {
    this.id = orderData.id;
    this.userId = orderData.userId;
    this.totalAmount = orderData.totalAmount;
    this.status = orderData.status || 'pending';
    this.createdAt = orderData.createdAt;
  }

  // Create a new order from user's cart
  static async createFromCart(userId) {
    const connection = await pool.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // Get cart items and total amount
      const cartItems = await Cart.getItems(userId);
      const totalAmount = await Cart.getTotal(userId);
      
      if (!cartItems.length) {
        throw new Error('Cannot create order from empty cart');
      }
      
      // Insert order
      const [orderResult] = await connection.execute(
        'INSERT INTO orders (user_id, total_amount, status) VALUES (?, ?, ?)',
        [userId, totalAmount, 'pending']
      );
      
      const orderId = orderResult.insertId;
      
      // Insert order items
      for (const item of cartItems) {
        await connection.execute(
          'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
          [orderId, item.product_id, item.quantity, item.price]
        );
      }
      
      // Clear the cart
      await Cart.clearCart(userId);
      
      await connection.commit();
      
      return orderId;
    } catch (error) {
      await connection.rollback();
      console.error('Error creating order:', error);
      throw error;
    } finally {
      connection.release();
    }
  }

  // Get order by ID
  static async findById(orderId, userId = null) {
    try {
      let query = `
        SELECT o.id, o.user_id, o.total_amount, o.status, o.created_at
        FROM orders o
        WHERE o.id = ?
      `;
      
      const params = [orderId];
      
      // If userId provided, only return order if it belongs to this user
      if (userId) {
        query += ' AND o.user_id = ?';
        params.push(userId);
      }
      
      const [orders] = await pool.execute(query, params);
      
      if (orders.length === 0) {
        return null;
      }
      
      const order = new Order(orders[0]);
      
      // Get order items
      const [items] = await pool.execute(
        `SELECT oi.id, oi.product_id, oi.quantity, oi.price,
                p.name, p.image
         FROM order_items oi
         JOIN products p ON oi.product_id = p.id
         WHERE oi.order_id = ?`,
        [orderId]
      );
      
      order.items = items;
      
      return order;
    } catch (error) {
      console.error('Error finding order:', error);
      throw error;
    }
  }

  // Get all orders for a user
  static async findByUser(userId) {
    try {
      const [orders] = await pool.execute(
        `SELECT id, user_id, total_amount, status, created_at
         FROM orders
         WHERE user_id = ?
         ORDER BY created_at DESC`,
        [userId]
      );
      
      return orders.map(order => new Order(order));
    } catch (error) {
      console.error('Error finding user orders:', error);
      throw error;
    }
  }

  // Get all orders (admin only)
  static async findAll() {
    try {
      const [orders] = await pool.execute(
        `SELECT o.id, o.user_id, o.total_amount, o.status, o.created_at,
                u.name, u.surname, u.email
         FROM orders o
         JOIN users u ON o.user_id = u.id
         ORDER BY o.created_at DESC`
      );
      
      return orders;
    } catch (error) {
      console.error('Error finding all orders:', error);
      throw error;
    }
  }

  // Update order status
  static async updateStatus(orderId, status) {
    try {
      const validStatuses = ['pending', 'processing', 'completed', 'cancelled'];
      
      if (!validStatuses.includes(status)) {
        throw new Error('Invalid order status');
      }
      
      const [result] = await pool.execute(
        'UPDATE orders SET status = ? WHERE id = ?',
        [status, orderId]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating order status:', error);
      throw error;
    }
  }
}

module.exports = Order;
```

### Order Controller Implementation (controllers/orderController.js)

```javascript
const Order = require('../models/Order');

// Create a new order from the cart
exports.createOrder = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const orderId = await Order.createFromCart(userId);
    
    res.status(201).json({
      message: 'Order created successfully',
      data: { orderId }
    });
  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({ message: error.message || 'Error creating order' });
  }
};

// Get user orders
exports.getUserOrders = async (req, res) => {
  try {
    const userId = req.user.id;
    
    const orders = await Order.findByUser(userId);
    
    res.json({ data: orders });
  } catch (error) {
    console.error('Error getting user orders:', error);
    res.status(500).json({ message: 'Error getting orders' });
  }
};

// Get order details
exports.getOrderDetails = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    
    // If regular user, only allow access to own orders
    const order = req.user.role === 'admin'
      ? await Order.findById(id)
      : await Order.findById(id, userId);
    
    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }
    
    res.json({ data: order });
  } catch (error) {
    console.error('Error getting order details:', error);
    res.status(500).json({ message: 'Error getting order details' });
  }
};

// Get all orders (admin only)
exports.getAllOrders = async (req, res) => {
  try {
    const orders = await Order.findAll();
    
    res.json({ data: orders });
  } catch (error) {
    console.error('Error getting all orders:', error);
    res.status(500).json({ message: 'Error getting orders' });
  }
};

// Update order status (admin only)
exports.updateOrderStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    const updated = await Order.updateStatus(id, status);
    
    if (!updated) {
      return res.status(404).json({ message: 'Order not found' });
    }
    
    res.json({
      message: 'Order status updated successfully',
      data: { orderId: id, status }
    });
  } catch (error) {
    console.error('Error updating order status:', error);
    res.status(500).json({ message: error.message || 'Error updating order status' });
  }
};
```

## 10. API Testing

Once your API is fully implemented, test all endpoints using a tool like Postman or Insomnia:

### User Endpoints
- `POST /api/auth/register`: Register a new user
- `POST /api/auth/login`: Log in a user
- `GET /api/auth/me`: Get current user's profile
- `PUT /api/users/profile`: Update user profile
- `GET /api/users`: Get all users (admin only)

### Product Endpoints
- `GET /api/products`: Get all products
- `GET /api/products/:id`: Get product by ID
- `POST /api/products`: Create a new product (admin only)
- `PUT /api/products/:id`: Update a product (admin only)
- `DELETE /api/products/:id`: Delete a product (admin only)

### Category Endpoints
- `GET /api/categories`: Get all categories
- `GET /api/categories/:id`: Get category by ID
- `GET /api/categories/:id/products`: Get products by category
- `POST /api/categories`: Create a new category (admin only)
- `PUT /api/categories/:id`: Update a category (admin only)
- `DELETE /api/categories/:id`: Delete a category (admin only)

### Cart Endpoints
- `GET /api/cart`: Get user's cart
- `POST /api/cart`: Add item to cart
- `PUT /api/cart/:productId`: Update cart item quantity
- `DELETE /api/cart/:productId`: Remove item from cart
- `DELETE /api/cart`: Clear cart

### Order Endpoints
- `POST /api/orders`: Create a new order
- `GET /api/orders`: Get user's orders
- `GET /api/orders/:id`: Get order details
- `GET /api/orders/all`: Get all orders (admin only)
- `PUT /api/orders/:id/status`: Update order status (admin only)

## 11. Security Best Practices

Implement these security measures to protect your API:

1. **Input Validation**: Use express-validator to validate and sanitize all inputs
   ```javascript
   const { body, validationResult } = require('express-validator');
   
   // Example validation for user registration
   const validateRegister = [
     body('name').notEmpty().withMessage('Name is required'),
     body('email').isEmail().withMessage('Must be a valid email'),
     body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
   ];
   
   router.post('/register', validateRegister, (req, res) => {
     const errors = validationResult(req);
     if (!errors.isEmpty()) {
       return res.status(400).json({ errors: errors.array() });
     }
     // Continue with registration
   });
   ```

2. **Rate Limiting**: Implement rate limiting to prevent brute force attacks
   ```bash
   npm install express-rate-limit
   ```
   
   ```javascript
   const rateLimit = require('express-rate-limit');
   
   const apiLimiter = rateLimit({
     windowMs: 15 * 60 * 1000, // 15 minutes
     max: 100, // limit each IP to 100 requests per windowMs
     message: 'Too many requests, please try again after 15 minutes'
   });
   
   // Apply to all requests
   app.use(apiLimiter);
   
   // Or apply to specific routes
   app.use('/api/auth/', authLimiter);
   ```

3. **Secure Headers**: Use helmet to set secure HTTP headers
   ```javascript
   const helmet = require('helmet');
   app.use(helmet());
   ```

4. **CORS Protection**: Configure CORS to only allow specified origins
   ```javascript
   const cors = require('cors');
   
   // For development
   app.use(cors());
   
   // For production
   const corsOptions = {
     origin: ['https://yourfrontend.com', 'https://admin.yourfrontend.com'],
     methods: ['GET', 'POST', 'PUT', 'DELETE'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     credentials: true
   };
   
   app.use(cors(corsOptions));
   ```

5. **JWT Best Practices**:
   - Use strong, randomly generated secrets
   - Set appropriate expiration times
   - Store tokens securely
   - Implement refresh token mechanism
   - Provide token revocation mechanism

6. **Error Handling**: Create a centralized error handler that doesn't leak sensitive information
   ```javascript
   // middleware/errorHandler.js
   module.exports = (err, req, res, next) => {
     console.error(err.stack);
     
     // Prevent leaking error details in production
     const statusCode = err.statusCode || 500;
     const message = process.env.NODE_ENV === 'production' && statusCode === 500
       ? 'Server error'
       : err.message;
     
     res.status(statusCode).json({
       message,
       error: process.env.NODE_ENV === 'development' ? err : {}
     });
   };
   ```

## 12. Deployment

Follow these steps to deploy your Node.js API to a production environment:

### Preparing for Production

1. **Environment Variables**:
   - Create a production `.env` file with secure credentials
   - Store sensitive information in environment variables, not in code
   - Use different values for development and production

2. **Optimize for Production**:
   ```javascript
   // Set NODE_ENV
   process.env.NODE_ENV = 'production';
   
   // Disable unnecessary logging
   if (process.env.NODE_ENV === 'production') {
     app.use(morgan('combined'));
   } else {
     app.use(morgan('dev'));
   }
   ```

3. **Build Process** (if using TypeScript or other transpiled language):
   ```bash
   npm run build
   ```

### Deployment Options

1. **Traditional VPS/Dedicated Server**:
   - Set up a Linux server (Ubuntu, Debian, etc.)
   - Install Node.js, MySQL, and other dependencies
   - Use PM2 for process management:
     ```bash
     npm install -g pm2
     pm2 start server.js --name="e-commerce-api"
     pm2 startup
     pm2 save
     ```

2. **Docker**:
   - Create a Dockerfile and docker-compose.yml
   - Build and run containers for Node.js API and MySQL
   - Example Dockerfile:
     ```dockerfile
     FROM node:16-alpine
     WORKDIR /app
     COPY package*.json ./
     RUN npm ci --only=production
     COPY . .
     EXPOSE 5000
     CMD ["node", "server.js"]
     ```

3. **Cloud Platform Services**:
   - **AWS**: Deploy on EC2, Elastic Beanstalk, or ECS
   - **Google Cloud**: App Engine or Cloud Run
   - **Azure**: App Service or AKS
   - **Heroku**: Easy deployment with Git integration
   
4. **Database Deployment**:
   - Set up a managed MySQL database (Amazon RDS, Google Cloud SQL)
   - Configure proper security (firewall, SSL connections)
   - Set up backups and monitoring

### SSL/HTTPS Setup

Always use HTTPS in production. Options include:

1. **Using a reverse proxy** like Nginx:
   ```
   server {
       listen 443 ssl;
       server_name api.yourdomain.com;
       
       ssl_certificate /path/to/certificate.crt;
       ssl_certificate_key /path/to/private.key;
       
       location / {
           proxy_pass http://localhost:5000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
       }
   }
   ```

2. **Let's Encrypt** for free SSL certificates:
   ```bash
   # Install certbot
   apt-get install certbot
   
   # Generate certificate
   certbot certonly --standalone -d api.yourdomain.com
   ```

3. **Cloud platform SSL options**:
   - AWS Certificate Manager
   - Google-managed SSL certificates
   - Heroku's SSL features

### CI/CD Integration

Set up continuous integration and deployment:

1. **GitHub Actions** workflow example:
   ```yaml
   name: Deploy API
   
   on:
     push:
       branches: [main]
   
   jobs:
     deploy:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v2
         - name: Setup Node.js
           uses: actions/setup-node@v2
           with:
             node-version: '16'
         - name: Install dependencies
           run: npm ci
         - name: Run tests
           run: npm test
         - name: Deploy to server
           uses: appleboy/ssh-action@master
           with:
             host: ${{ secrets.SERVER_HOST }}
             username: ${{ secrets.SERVER_USER }}
             key: ${{ secrets.SSH_PRIVATE_KEY }}
             script: |
               cd /path/to/api
               git pull
               npm ci --only=production
               pm2 restart e-commerce-api
   ```

### Monitoring and Logging

Set up monitoring and logging for your production API:

1. **Application Performance Monitoring**:
   - Install and configure New Relic, Datadog, or similar APM service
   
2. **Logging**:
   ```bash
   npm install winston
   ```
   
   ```javascript
   const winston = require('winston');
   
   const logger = winston.createLogger({
     level: 'info',
     format: winston.format.json(),
     defaultMeta: { service: 'e-commerce-api' },
     transports: [
       new winston.transports.File({ filename: 'error.log', level: 'error' }),
       new winston.transports.File({ filename: 'combined.log' })
     ]
   });
   
   if (process.env.NODE_ENV !== 'production') {
     logger.add(new winston.transports.Console({
       format: winston.format.simple()
     }));
   }
   
   module.exports = logger;
   ```

3. **Alerting**:
   - Set up alerts for critical errors and performance issues
   - Configure alerting channels (email, SMS, Slack, etc.)

By following this comprehensive guide, you'll have a production-ready Node.js API that can replace the PHP backend for your e-commerce application and be accessed by the React Native mobile client.

## 13. Advanced API Features

### Implementing Real-time Features

For real-time updates in your e-commerce application, consider implementing WebSockets:

```javascript
// Install dependencies
// npm install socket.io

// In server.js
const http = require('http');
const socketIo = require('socket.io');
const app = require('./app');

const server = http.createServer(app);
const io = socketIo(server);

// Socket.io setup
io.on('connection', (socket) => {
  console.log('New client connected');
  
  // Join a room based on user ID for targeted updates
  socket.on('join', (userId) => {
    socket.join(`user-${userId}`);
  });
  
  // Admin notifications
  socket.on('joinAdmin', () => {
    socket.join('admin-room');
  });
  
  socket.on('disconnect', () => {
    console.log('Client disconnected');
  });
});

// Emit order status updates
function emitOrderUpdate(orderId, userId, status) {
  io.to(`user-${userId}`).emit('orderStatusUpdate', { orderId, status });
  io.to('admin-room').emit('newOrderUpdate', { orderId, userId, status });
}

// Expose the emitter for use in controllers
app.set('socketEmitter', { emitOrderUpdate });

// Start the server on a specific port
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### Advanced Search with Full-text Indexing

To implement powerful search capabilities:

1. Add full-text search to your MySQL schema:

```sql
-- Add full-text index to products table
ALTER TABLE products ADD FULLTEXT(name, description);
```

2. Implement in your Product model:

```javascript
// In models/Product.js
static async searchProducts(query, limit = 20, offset = 0) {
  try {
    const [rows] = await pool.execute(
      `SELECT p.*, c.name as category_name
       FROM products p
       LEFT JOIN categories c ON p.category_id = c.id
       WHERE MATCH(p.name, p.description) AGAINST(? IN NATURAL LANGUAGE MODE)
       LIMIT ? OFFSET ?`,
      [query, limit, offset]
    );
    
    return rows;
  } catch (error) {
    console.error('Error searching products:', error);
    throw error;
  }
}
```

### Implementing Rate Limiting

Protect your API from abuse with rate limiting:

```javascript
// Install dependencies
// npm install express-rate-limit

// In middleware/rateLimit.js
const rateLimit = require('express-rate-limit');

// Create rate limiters with different configurations
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests per windowMs
  message: 'Too many login attempts, please try again after 15 minutes'
});

const apiLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 100, // 100 requests per hour
  message: 'Too many requests from this IP, please try again after an hour'
});

// For store API calls
const productLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 30, // 30 requests per minute
  message: 'Too many product requests, please slow down'
});

module.exports = {
  authLimiter,
  apiLimiter,
  productLimiter
};
```

### File Upload with Image Processing

Enhance product image uploads with image processing:

```javascript
// Install dependencies
// npm install multer sharp

// In middleware/upload.js
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;

// Set storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/temp');
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

// Filter for images only
const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed'), false);
  }
};

// Initialize upload middleware
const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter
});

// Process uploaded image
const processImage = async (req, res, next) => {
  if (!req.file) return next();
  
  try {
    // Create directory if not exists
    const outputDir = path.join(__dirname, '../uploads/products');
    await fs.mkdir(outputDir, { recursive: true });
    
    // Generate unique filename
    const filename = `product-${Date.now()}.webp`;
    const outputPath = path.join(outputDir, filename);
    
    // Process image - resize and convert to webp
    await sharp(req.file.path)
      .resize(800) // max width 800px
      .webp({ quality: 80 })
      .toFile(outputPath);
    
    // Delete temporary file
    await fs.unlink(req.file.path);
    
    // Set optimized path for use in controller
    req.optimizedImage = `/uploads/products/${filename}`;
    next();
  } catch (error) {
    next(error);
  }
};

module.exports = {
  upload,
  processImage
};
```

### Advanced Authentication

Implement more robust authentication with refresh tokens:

```javascript
// In models/User.js
class User {
  // ... existing code ...
  
  // Generate refresh token
  static async generateRefreshToken(userId) {
    try {
      const refreshToken = crypto.randomBytes(40).toString('hex');
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
      
      await pool.execute(
        'INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES (?, ?, ?)',
