## 4. Models Implementation

### User Model (models/User.js)

```javascript
const { pool } = require('../config/db');
const bcrypt = require('bcryptjs');

class User {
  constructor(userData) {
    this.id = userData.id;
    this.name = userData.name;
    this.surname = userData.surname;
    this.email = userData.email;
    this.phone = userData.phone;
    this.password = userData.password;
    this.profileImage = userData.profileImage || 'default-profile.png';
    this.role = userData.role || 'customer';
  }

  // Register a new user
  async register() {
    try {
      // Hash the password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(this.password, salt);
      
      const query = `
        INSERT INTO users (name, surname, email, phone, passwordHash, profileImage, role, registrationDate) 
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
      `;
      
      const [result] = await pool.execute(query, [
        this.name,
        this.surname,
        this.email,
        this.phone,
        hashedPassword,
        this.profileImage,
        this.role
      ]);
      
      return result.insertId;
    } catch (error) {
      console.error('Error in user registration:', error);
      throw error;
    }
  }

  // Check if email exists
  static async emailExists(email) {
    try {
      const [rows] = await pool.execute(
        'SELECT userID FROM users WHERE email = ? LIMIT 1',
        [email]
      );
      return rows.length > 0;
    } catch (error) {
      console.error('Error checking email existence:', error);
      throw error;
    }
  }

  // Check if phone exists
  static async phoneExists(phone) {
    try {
      const [rows] = await pool.execute(
        'SELECT userID FROM users WHERE phone = ? LIMIT 1',
        [phone]
      );
      return rows.length > 0;
    } catch (error) {
      console.error('Error checking phone existence:', error);
      throw error;
    }
  }

  // Login user with email or phone
  static async login(loginId, password) {
    try {
      const [rows] = await pool.execute(
        'SELECT userID, name, surname, email, phone, passwordHash, profileImage, role FROM users WHERE email = ? OR phone = ? LIMIT 1',
        [loginId, loginId]
      );
      
      if (rows.length === 0) {
        return null;
      }
      
      const user = rows[0];
      const isMatch = await bcrypt.compare(password, user.passwordHash);
      
      if (!isMatch) {
        return null;
      }
      
      return {
        id: user.userID,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        profileImage: user.profileImage,
        role: user.role
      };
    } catch (error) {
      console.error('Error in user login:', error);
      throw error;
    }
  }

  // Get user by ID
  static async findById(id) {
    try {
      const [rows] = await pool.execute(
        'SELECT userID, name, surname, email, phone, profileImage, role FROM users WHERE userID = ? LIMIT 1',
        [id]
      );
      
      if (rows.length === 0) {
        return null;
      }
      
      const userData = rows[0];
      return {
        id: userData.userID,
        name: userData.name,
        surname: userData.surname,
        email: userData.email,
        phone: userData.phone,
        profileImage: userData.profileImage,
        role: userData.role
      };
    } catch (error) {
      console.error('Error finding user by ID:', error);
      throw error;
    }
  }

  // Update user profile
  async update() {
    try {
      const query = `
        UPDATE users 
        SET name = ?, surname = ?, email = ?, phone = ?, profileImage = ?
        WHERE userID = ?
      `;
      
      const [result] = await pool.execute(query, [
        this.name,
        this.surname,
        this.email,
        this.phone,
        this.profileImage,
        this.id
      ]);
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating user:', error);
      throw error;
    }
  }

  // Update password
  async updatePassword() {
    try {
      // Hash the new password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(this.password, salt);
      
      const [result] = await pool.execute(
        'UPDATE users SET passwordHash = ? WHERE userID = ?',
        [hashedPassword, this.id]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating password:', error);
      throw error;
    }
  }

  // Delete user account
  async delete() {
    try {
      // Check if this is the only admin account
      if (this.role === 'admin') {
        const [rows] = await pool.execute(
          'SELECT COUNT(*) as count FROM users WHERE role = "admin"'
        );
        
        if (rows[0].count <= 1) {
          // This is the only admin account, don't allow deletion
          return false;
        }
      }
      
      // Use a transaction to ensure all operations succeed or fail together
      const connection = await pool.getConnection();
      await connection.beginTransaction();
      
      try {
        // Delete user's orders first (since they have foreign key constraints)
        await connection.execute('DELETE FROM orders WHERE userID = ?', [this.id]);
        
        // Now delete the user
        const [result] = await connection.execute(
          'DELETE FROM users WHERE userID = ?', 
          [this.id]
        );
        
        await connection.commit();
        connection.release();
        
        return result.affectedRows > 0;
      } catch (error) {
        await connection.rollback();
        connection.release();
        throw error;
      }
    } catch (error) {
      console.error('Error deleting user:', error);
      throw error;
    }
  }
}

module.exports = User;
```

### Category Model (models/Category.js)

```javascript
const { pool } = require('../config/db');

class Category {
  constructor(categoryData) {
    this.id = categoryData.id;
    this.name = categoryData.name;
  }

  // Get all categories
  static async getAll() {
    try {
      const [rows] = await pool.execute(
        'SELECT categoryID as id, name FROM categories ORDER BY name'
      );
      return rows;
    } catch (error) {
      console.error('Error getting categories:', error);
      throw error;
    }
  }

  // Get category by ID
  static async getById(id) {
    try {
      const [rows] = await pool.execute(
        'SELECT categoryID as id, name FROM categories WHERE categoryID = ? LIMIT 1',
        [id]
      );
      
      if (rows.length === 0) {
        return null;
      }
      
      return rows[0];
    } catch (error) {
      console.error('Error getting category:', error);
      throw error;
    }
  }

  // Create a new category
  async create() {
    try {
      const [result] = await pool.execute(
        'INSERT INTO categories (name) VALUES (?)',
        [this.name]
      );
      
      this.id = result.insertId;
      return this.id;
    } catch (error) {
      console.error('Error creating category:', error);
      throw error;
    }
  }

  // Update a category
  async update() {
    try {
      const [result] = await pool.execute(
        'UPDATE categories SET name = ? WHERE categoryID = ?',
        [this.name, this.id]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating category:', error);
      throw error;
    }
  }

  // Delete a category
  async delete() {
    try {
      const [result] = await pool.execute(
        'DELETE FROM categories WHERE categoryID = ?',
        [this.id]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error deleting category:', error);
      throw error;
    }
  }
}

module.exports = Category;
```

### Product Model (models/Product.js)

```javascript
const { pool } = require('../config/db');

class Product {
  constructor(productData) {
    this.id = productData.id;
    this.name = productData.name;
    this.description = productData.description;
    this.price = productData.price;
    this.category_id = productData.category_id;
    this.image = productData.image;
    this.active = productData.active !== undefined ? productData.active : 1;
    this.featured = productData.featured !== undefined ? productData.featured : 0;
  }

  // Get all products with optional search and category filter
  static async getAll(search = '', categoryId = null) {
    try {
      let query = `
        SELECT p.productID as id, p.name, p.description, p.price, p.imagePath as image,
               c.categoryID as category_id, c.name as category_name
        FROM products p
        LEFT JOIN categories c ON p.category = c.categoryID
        WHERE p.active = 1
      `;
      
      const params = [];
      
      if (search) {
        query += ' AND (p.name LIKE ? OR p.description LIKE ?)';
        params.push(`%${search}%`, `%${search}%`);
      }
      
      if (categoryId) {
        query += ' AND p.category = ?';
        params.push(categoryId);
      }
      
      query += ' ORDER BY p.productID DESC';
      
      const [rows] = await pool.execute(query, params);
      return rows;
    } catch (error) {
      console.error('Error getting products:', error);
      throw error;
    }
  }

  // Get product by ID
  static async getById(id) {
    try {
      const query = `
        SELECT p.productID as id, p.name, p.description, p.price, p.imagePath as image,
               c.categoryID as category_id, c.name as category_name
        FROM products p
        LEFT JOIN categories c ON p.category = c.categoryID
        WHERE p.productID = ?
        LIMIT 1
      `;
      
      const [rows] = await pool.execute(query, [id]);
      
      if (rows.length === 0) {
        return null;
      }
      
      return rows[0];
    } catch (error) {
      console.error('Error getting product:', error);
      throw error;
    }
  }

  // Create a new product
  async create() {
    try {
      const query = `
        INSERT INTO products (name, description, price, category, imagePath)
        VALUES (?, ?, ?, ?, ?)
      `;
      
      const [result] = await pool.execute(query, [
        this.name,
        this.description,
        this.price,
        this.category_id,
        this.image
      ]);
      
      this.id = result.insertId;
      return this.id;
    } catch (error) {
      console.error('Error creating product:', error);
      throw error;
    }
  }

  // Update a product
  async update() {
    try {
      let query = `
        UPDATE products
        SET name = ?, description = ?, price = ?, category = ?
      `;
      
      const params = [
        this.name,
        this.description,
        this.price,
        this.category_id
      ];
      
      // Only update image if a new one is provided
      if (this.image) {
        query += ', imagePath = ?';
        params.push(this.image);
      }
      
      query += ' WHERE productID = ?';
      params.push(this.id);
      
      const [result] = await pool.execute(query, params);
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating product:', error);
      throw error;
    }
  }

  // Delete a product (soft or hard delete)
  async delete() {
    try {
      // Check if product has any order references
      const [rows] = await pool.execute(
        'SELECT COUNT(*) as count FROM order_items WHERE productID = ?',
        [this.id]
      );
      
      if (rows[0].count > 0) {
        // Product has orders, soft delete by marking as inactive
        const [result] = await pool.execute(
          'UPDATE products SET active = 0 WHERE productID = ?',
          [this.id]
        );
        return result.affectedRows > 0;
      } else {
        // No order references, safe to hard delete
        const [result] = await pool.execute(
          'DELETE FROM products WHERE productID = ?',
          [this.id]
        );
        return result.affectedRows > 0;
      }
    } catch (error) {
      console.error('Error deleting product:', error);
      throw error;
    }
  }

  // Get random products
  static async getRandomProducts(limit = 4) {
    try {
      const query = `
        SELECT p.productID, p.name, p.description, p.price, p.imagePath as image,
               c.name as category_name
        FROM products p
        LEFT JOIN categories c ON p.category = c.categoryID
        WHERE p.active = 1
        ORDER BY RAND()
        LIMIT ?
      `;
      
      const [rows] = await pool.execute(query, [limit]);
      return rows;
    } catch (error) {
      console.error('Error getting random products:', error);
      throw error;
    }
  }
}

module.exports = Product;
```

### Order Model (models/Order.js)

```javascript
const { pool } = require('../config/db');

class Order {
  constructor(orderData) {
    this.id = orderData.id;
    this.user_id = orderData.user_id;
    this.total_amount = orderData.total_amount;
    this.status = orderData.status || 'pending';
    this.created_at = orderData.created_at;
    this.items = orderData.items || [];
  }

  // Create a new order
  async create() {
    const connection = await pool.getConnection();
    
    try {
      // Begin transaction
      await connection.beginTransaction();
      
      // Insert order
      const [orderResult] = await connection.execute(
        'INSERT INTO orders (userID, totalPrice, status) VALUES (?, ?, ?)',
        [this.user_id, this.total_amount, this.status]
      );
      
      this.id = orderResult.insertId;
      
      // Insert order items
      for (const item of this.items) {
        await connection.execute(
          'INSERT INTO order_items (orderID, productID, quantity) VALUES (?, ?, ?)',
          [this.id, item.product_id, item.quantity]
        );
      }
      
      // Commit transaction
      await connection.commit();
      return this.id;
    } catch (error) {
      // Rollback on error
      await connection.rollback();
      console.error('Error creating order:', error);
      throw error;
    } finally {
      connection.release();
    }
  }

  // Get all orders with optional user filter
  static async getAll(userId = null) {
    try {
      let query = `
        SELECT o.orderID as id, o.userID as user_id, o.totalPrice as total_amount, 
               o.status, o.orderDate as created_at, u.name, u.surname, u.email
        FROM orders o
        LEFT JOIN users u ON o.userID = u.userID
      `;
      
      const params = [];
      
      if (userId) {
        query += ' WHERE o.userID = ?';
        params.push(userId);
      }
      
      query += ' ORDER BY o.orderDate DESC';
      
      const [rows] = await pool.execute(query, params);
      return rows;
    } catch (error) {
      console.error('Error getting orders:', error);
      throw error;
    }
  }

  // Get order by ID with order items
  static async getById(id) {
    try {
      // Get order
      const [orderRows] = await pool.execute(
        `SELECT o.orderID as id, o.userID as user_id, o.totalPrice as total_amount, 
                o.status, o.orderDate as created_at, u.name, u.surname, u.email
         FROM orders o
         LEFT JOIN users u ON o.userID = u.userID
         WHERE o.orderID = ? LIMIT 1`,
        [id]
      );
      
      if (orderRows.length === 0) {
        return null;
      }
      
      const order = orderRows[0];
      
      // Get order items
      const [itemsRows] = await pool.execute(
        `SELECT oi.productID as product_id, oi.quantity,
                p.name as product_name, p.price, p.imagePath as product_image
         FROM order_items oi
         LEFT JOIN products p ON oi.productID = p.productID
         WHERE oi.orderID = ?`,
        [id]
      );
      
      order.items = itemsRows;
      
      return order;
    } catch (error) {
      console.error('Error getting order:', error);
      throw error;
    }
  }

  // Update order status
  async updateStatus() {
    try {
      // Validate status value to match database enum values
      const allowed_statuses = ['pending', 'processing', 'completed', 'cancelled'];
      if (!allowed_statuses.includes(this.status)) {
        return false;
      }
      
      const [result] = await pool.execute(
        'UPDATE orders SET status = ? WHERE orderID = ?',
        [this.status, this.id]
      );
      
      return result.affectedRows > 0;
    } catch (error) {
      console.error('Error updating order status:', error);
      throw error;
    }
  }
}

module.exports = Order;
```
